## How to write a linux i2c driver

This article will tell you how to write a i2c driver for an external device like PCA9685 or some sensors using i2c interface. This tutorial is based on the latest Linux kernel 5.x.x. However, the general structure is the same even in kenel 2.6.0, just some new features (`regmap pm_ops`) were not supported.

### Build the driver structure

First we need to provider the i2c driver with necessary information about the device, `probe` and `remove` routines, etc. For example:

```c
/* The device names to be registered into i2c table */
static struct i2c_device_id foo_idtable[] = {
	{ "foo", my_id_for_foo },
	{ "bar", my_id_for_bar },
	{ }
};

/* Tell user space about which devices the module supports */
MODULE_DEVICE_TABLE(i2c, foo_idtable);
// MODULE_ALIAS("foo_alias");

/* Driver itself provides general methods */
static struct i2c_driver foo_driver = {
	.driver = {
    /* Matched i2c device name, must not contain spaces */
		.name	= "foo",
    /* Power manage ops */
		.pm	= &foo_pm_ops,	/* optional */
	},
  
	.id_table	= foo_idtable,
	.probe		= foo_probe, /* Callback for probe routine */
	.remove		= foo_remove, /* Callback for remove routine */
  
	/* if device autodetection is needed: (talk later)*/
	.class		= I2C_CLASS_SOMETHING,
	.detect		= foo_detect,
	.address_list	= normal_i2c,
  
	.shutdown	= foo_shutdown,	/* Callback when computer shutdown or reboot */
	.command	= foo_command,	/* optional, deprecated */
}
```

If we [instantiate a i2c device in userspace](https://www.kernel.org/doc/Documentation/i2c/instantiating-devices) with:

```sh
# Instantiate an i2c device foo at address 0x50
echo foo 0x50 > /sys/bus/i2c/devices/i2c-3/new_device
```

The kernel will find `foo_driver` according to the name `foo` and use contained methods for common routines.



### Understand the client structure

If you read the code in the driver part you will notice there is no operation methods like read and write. This is because a driver structure only contains general access routines (through some callback functions). It is used for the kernel to manage the device at certain events like shutdown, sleep, or device is removed. 

The client structure contains all the information of the slave device, like shown below, code is cut from the linux mainline [i2c driver source code](https://github.com/torvalds/linux/blob/master/include/linux/i2c.h#L298):

```c
/**
 * struct i2c_client - represent an I2C slave device
 * @flags: see I2C_CLIENT_* for possible flags
 * @addr: Address used on the I2C bus connected to the parent adapter.
 * @name: Indicates the type of the device, usually a chip name that's
 *	generic enough to hide second-sourcing and compatible revisions.
 * @adapter: manages the bus segment hosting this I2C device
 * @dev: Driver model device node for the slave.
 * @init_irq: IRQ that was set at initialization
 * @irq: indicates the IRQ generated by this device (if any)
 * @detected: member of an i2c_driver.clients list or i2c-core's
 *	userspace_devices list
 * @slave_cb: Callback when I2C slave mode of an adapter is used. The adapter
 *	calls it to pass on slave events to the slave driver.
 * @devres_group_id: id of the devres group that will be created for resources
 *	acquired when probing this device.
 *
 * An i2c_client identifies a single device (i.e. chip) connected to an
 * i2c bus. The behaviour exposed to Linux is defined by the driver
 * managing the device.
 */
struct i2c_client {
	unsigned short flags;		/* div., see below		*/
#define I2C_CLIENT_PEC		0x04	/* Use Packet Error Checking */
#define I2C_CLIENT_TEN		0x10	/* we have a ten bit chip address */
					/* Must equal I2C_M_TEN below */
#define I2C_CLIENT_SLAVE	0x20	/* we are the slave */
#define I2C_CLIENT_HOST_NOTIFY	0x40	/* We want to use I2C host notify */
#define I2C_CLIENT_WAKE		0x80	/* for board_info; true iff can wake */
#define I2C_CLIENT_SCCB		0x9000	/* Use Omnivision SCCB protocol */
					/* Must match I2C_M_STOP|IGNORE_NAK */

	unsigned short addr;		/* chip address - NOTE: 7bit	*/
					/* addresses are stored in the	*/
					/* _LOWER_ 7 bits		*/
	char name[I2C_NAME_SIZE];
	struct i2c_adapter *adapter;	/* the adapter we sit on	*/
	struct device dev;		/* the device structure		*/
	int init_irq;			/* irq set at initialization	*/
	int irq;			/* irq issued by device		*/
	struct list_head detected;
#if IS_ENABLED(CONFIG_I2C_SLAVE)
	i2c_slave_cb_t slave_cb;	/* callback for slave mode	*/
#endif
	void *devres_group_id;		/* ID of probe devres group	*/
};
```




#### Extra client data

Each client structure has a special data field that can point to any structure at all. You should use this to keep device-specific data.

```c
/* store the value */
void i2c_set_clientdata(struct i2c_client *client, void *data);

/* retrieve the value */
void *i2c_get_clientdata(const struct i2c_client *client);
```

The i2c client structure is different from the driver structure, you probably want it


Reference list:

1. https://www.kernel.org/doc/Documentation/i2c/writing-clients
2. https://www.kernel.org/doc/Documentation/i2c/instantiating-devices
3. https://www.kernel.org/doc/Documentation/i2c/dev-interface
4. https://github.com/torvalds/linux/blob/master/drivers/pwm/pwm-pca9685.c
